part of 'workout_bloc.dart';

abstract class WorkoutEvent extends Equatable {
  const WorkoutEvent();

  @override
  List<Object?> get props => [];
}

class WorkoutStarted extends WorkoutEvent {
  final WorkoutType type;
  final CustomWorkout? workoutToFollow;

  const WorkoutStarted(this.type, {this.workoutToFollow});

  @override
  List<Object?> get props => [type, workoutToFollow];
}

class WorkoutCancelled extends WorkoutEvent {}

class WorkoutFinished extends WorkoutEvent {
  final int? reps;
  final double? weight;
  final Duration? duration;
  const WorkoutFinished({this.reps, this.weight, this.duration});

  @override
  List<Object?> get props => [reps, weight, duration];
}

class ExerciseAdded extends WorkoutEvent {
  final String exerciseId;
  final String name;
  final String muscleGroup;
  final String? equipmentId;

  const ExerciseAdded({
    required this.exerciseId,
    required this.name,
    required this.muscleGroup,
    this.equipmentId,
  });

  @override
  List<Object?> get props => [exerciseId, name, muscleGroup, equipmentId];
}

class SetAdded extends WorkoutEvent {
  final int reps;
  final double weight;
  final Duration duration;

  const SetAdded({
    required this.reps,
    required this.weight,
    required this.duration,
  });

  @override
  List<Object> get props => [reps, weight, duration];
}

class WorkoutLoaded extends WorkoutEvent {}

class WorkoutHistoryRequested extends WorkoutEvent {}

class UpcomingExercisesReordered extends WorkoutEvent {
  final int
  startIndex; // index in workoutToFollow.exercises where reordering begins
  final List<String>
  newOrderIds; // ids of exercises in their new order for the reorderable suffix
  const UpcomingExercisesReordered(this.startIndex, this.newOrderIds);
  @override
  List<Object?> get props => [startIndex, newOrderIds];
}

/// Internal: enter a set phase (start or resume a set). Triggered by bloc transitions.
class RunEnterSet extends WorkoutEvent {
  const RunEnterSet();
}

/// Internal: enter a rest phase with a given total rest duration.
class RunEnterRest extends WorkoutEvent {
  final Duration restDuration;
  const RunEnterRest(this.restDuration);
  @override
  List<Object?> get props => [restDuration];
}

/// Tick for active set (elapsed +1s). Generated by bloc timer.
class RunSetTick extends WorkoutEvent {
  const RunSetTick();
}

/// Tick for rest phase (remaining -1s). Generated by bloc timer.
class RunRestTick extends WorkoutEvent {
  const RunRestTick();
}

/// User finishes the current interactive segment (set/exercise/workout). Bloc decides which.
class RunFinishCurrent extends WorkoutEvent {
  /// Weight lifted in the set in kg.
  final double weight;

  /// Number of reps completed in the set.
  final int reps;

  /// Duration of the set.
  final Duration duration;

  /// Creates a RunFinishCurrent event.
  const RunFinishCurrent({
    required this.weight,
    required this.reps,
    required this.duration,
  });
  @override
  List<Object?> get props => [weight, reps, duration];
}

/// User skips the remaining rest (only valid in rest phase).
class RunSkipRest extends WorkoutEvent {
  const RunSkipRest();
}

/// User extends the rest by a number of seconds (default +30).
class RunExtendRest extends WorkoutEvent {
  final int seconds;
  const RunExtendRest({this.seconds = 30});
  @override
  List<Object?> get props => [seconds];
}

/// User chooses to finish workout early (per requirements: only allowed during rest, not mid-set).
class RunFinishEarly extends WorkoutEvent {
  const RunFinishEarly();
}

/// UI intent (free workout only): user wants to enter the exercise selection
/// mode (e.g. from rest phase or before starting). This does not mutate the
/// underlying workout; it is a pure presentation directive that the
/// orchestration screen will react to. The bloc currently does not emit a
/// dedicated state for this (handled locally), but the event is defined now
/// for parity with custom workout flow and future possible centralization.
class FreeWorkoutEnterSelection extends WorkoutEvent {
  const FreeWorkoutEnterSelection();
}

/// Free workout consolidated intent: ensure workout is started, ensure the
/// specified exercise becomes the current (last) exercise, and transition into
/// an active set if appropriate (skipping rest when needed). Replaces the UI
/// chain previously performed in `ExerciseScreen._startSet`.
class FreeWorkoutFocusExercise extends WorkoutEvent {
  final String exerciseId;
  final String name;
  final String muscleGroup;
  final String? equipmentId;

  const FreeWorkoutFocusExercise({
    required this.exerciseId,
    required this.name,
    required this.muscleGroup,
    this.equipmentId,
  });

  @override
  List<Object?> get props => [exerciseId, name, muscleGroup, equipmentId];
}

/// Pause the rest countdown (free workout selection mode). Internal timer stops
/// but remaining duration is preserved.
class RunPauseRest extends WorkoutEvent {
  const RunPauseRest();
}

/// Resume a previously paused rest countdown.
class RunResumeRest extends WorkoutEvent {
  const RunResumeRest();
}
